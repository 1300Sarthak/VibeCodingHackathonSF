// Background script (service worker)\n\n// Initial state: widget is on by default\nchrome.runtime.onInstalled.addListener(() => {\n  chrome.storage.local.set({ widgetState: {} }); // Use an object to store state per tab\n});\n\n// Listen for clicks on the browser action button\nchrome.action.onClicked.addListener(async (tab) => {\n  if (!tab.id) return; // Ensure tab has an ID\n\n  // Get current state for the tab\n  const result = await chrome.storage.local.get(\'widgetState\');\n  const widgetState = result.widgetState || {};\n  const currentState = widgetState[tab.id] !== undefined ? widgetState[tab.id] : true; // Default to true if not set\n\n  // Toggle state\n  const newState = !currentState;\n  widgetState[tab.id] = newState;\n\n  // Save new state\n  await chrome.storage.local.set({ widgetState });\n\n  // Send message to content script to toggle visibility\n  chrome.tabs.sendMessage(tab.id, { action: \'toggleWidget\', isVisible: newState }).catch(error => {\n    // Catch errors if content script is not yet injected (e.g., page not fully loaded)\n    console.warn(\`[GhostGov Background] Could not send message to tab ${tab.id}: \${error.message}\`);\n    // If content script is not ready, it will read the state from storage when it loads\n  });\n\n  // Update the icon (optional but good UX)\n  updateIcon(tab.id, newState);\n});\n\n// Function to update the icon based on the state\nfunction updateIcon(tabId: number, isVisible: boolean) {\n  const iconPath = isVisible ? {\n    \"16\": \"icon16.png\",\n    \"48\": \"icon48.png\",\n    \"128\": \"icon128.png\"\n  } : {\n    \"16\": \"icon16_disabled.png\", // You\'ll need to create disabled icons\n    \"48\": \"icon48_disabled.png\",\n    \"128\": \"icon128_disabled.png\"\n  };\n  chrome.action.setIcon({ tabId: tabId, path: iconPath });\n}\n\n// Listen for tab updates (e.g., page navigation) to set the correct icon and potentially inject content script if needed\nchrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {\n  if (changeInfo.status === \'complete\' && tab.url && tab.id) {\n    // Get state for the tab\n    const result = await chrome.storage.local.get(\'widgetState\');\n    const widgetState = result.widgetState || {};\n    const isVisible = widgetState[tab.id] !== undefined ? widgetState[tab.id] : true; // Default to true\n\n    // Update icon\n    updateIcon(tab.id, isVisible);\n\n    // We don\'t need to manually inject the content script here because manifest.json handles it on document_end\n    // However, we should send the initial state to the content script in case it loaded before the message listener was set up\n     chrome.tabs.sendMessage(tab.id, { action: \'setInitialState\', isVisible: isVisible }).catch(error => {\n       // Content script might not be ready yet, ignore error\n     });\n  }\n});\n\n// Clean up state when a tab is closed\nchrome.tabs.onRemoved.addListener((tabId) => {\n  chrome.storage.local.get(\'widgetState\', (result) => {\n    const widgetState = result.widgetState || {};\n    delete widgetState[tabId];\n    chrome.storage.local.set({ widgetState });\n  });\n}); 